// Web-compatible YouTube Music API implementation for Vercel deployment

export interface YtDlpSong {
  id: string
  title: string
  artist: string
  thumbnail: string
  duration: string
  url: string
  audioUrl: string
  formats?: YtDlpFormat[]
}

export interface YtDlpFormat {
  format_id: string
  url: string
  ext: string
  acodec: string
  abr?: number
  filesize?: number
}

export interface YtDlpVideoInfo {
  id: string
  title: string
  uploader: string
  thumbnail: string
  duration: number
  webpage_url: string
  formats: YtDlpFormat[]
}

class YtDlpExtractor {
  private readonly YOUTUBE_API_KEY = process.env.YOUTUBE_API_KEY || "AIzaSyBIQVGnXO2T7smsxf6q_MWxMD1sQzek1Nc"
  private readonly YOUTUBE_BASE_URL = "https://www.googleapis.com/youtube/v3"

  async getTrending(maxResults = 25): Promise<YtDlpSong[]> {
    console.log("[v0] YtDlp: Fetching trending music from YouTube API")

    try {
      // Get trending music videos from YouTube API
      const response = await fetch(
        `${this.YOUTUBE_BASE_URL}/videos?` +
          `part=snippet,contentDetails&` +
          `chart=mostPopular&` +
          `videoCategoryId=10&` + // Music category
          `regionCode=US&` +
          `maxResults=${maxResults}&` +
          `key=${this.YOUTUBE_API_KEY}`,
      )

      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status}`)
      }

      const data = await response.json()
      console.log("[v0] YtDlp: Got", data.items?.length || 0, "trending videos from YouTube")

      if (!data.items || data.items.length === 0) {
        throw new Error("No trending videos from YouTube API")
      }

      // Convert YouTube videos to songs format
      const songs: YtDlpSong[] = data.items.map((item: any) => ({
        id: item.id,
        title: item.snippet.title,
        artist: item.snippet.channelTitle,
        thumbnail: item.snippet.thumbnails?.high?.url || item.snippet.thumbnails?.medium?.url || "",
        duration: this.parseDuration(item.contentDetails?.duration || "PT0S"),
        url: `https://www.youtube.com/watch?v=${item.id}`,
        audioUrl: "", // Will be populated when needed
        formats: [],
      }))

      console.log("[v0] YtDlp: Successfully converted", songs.length, "songs")
      return songs
    } catch (error) {
      console.error("[v0] YtDlp: Trending failed:", error)
      throw error
    }
  }

  async search(query: string, maxResults = 15): Promise<YtDlpSong[]> {
    console.log("[v0] YtDlp: Searching YouTube API for:", query)

    try {
      const response = await fetch(
        `${this.YOUTUBE_BASE_URL}/search?` +
          `part=snippet&` +
          `q=${encodeURIComponent(query + " music")}&` +
          `type=video&` +
          `videoCategoryId=10&` +
          `maxResults=${maxResults}&` +
          `key=${this.YOUTUBE_API_KEY}`,
      )

      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status}`)
      }

      const data = await response.json()
      console.log("[v0] YtDlp: Got", data.items?.length || 0, "search results from YouTube")

      if (!data.items || data.items.length === 0) {
        return []
      }

      // Convert YouTube search results to songs format
      const songs: YtDlpSong[] = data.items.map((item: any) => ({
        id: item.id.videoId,
        title: item.snippet.title,
        artist: item.snippet.channelTitle,
        thumbnail: item.snippet.thumbnails?.high?.url || item.snippet.thumbnails?.medium?.url || "",
        duration: "Unknown", // Duration not available in search results
        url: `https://www.youtube.com/watch?v=${item.id.videoId}`,
        audioUrl: "", // Will be populated when needed
        formats: [],
      }))

      console.log("[v0] YtDlp: Successfully converted", songs.length, "search results")
      return songs
    } catch (error) {
      console.error("[v0] YtDlp: Search failed:", error)
      throw error
    }
  }

  async getVideoInfo(videoId: string): Promise<YtDlpVideoInfo | null> {
    console.log("[v0] YtDlp: Getting video info for:", videoId)

    try {
      // Use YouTube API to get video details
      const response = await fetch(
        `${this.YOUTUBE_BASE_URL}/videos?` +
          `part=snippet,contentDetails&` +
          `id=${videoId}&` +
          `key=${this.YOUTUBE_API_KEY}`,
      )

      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status}`)
      }

      const data = await response.json()
      
      if (!data.items || data.items.length === 0) {
        return null
      }

      const item = data.items[0]
      return {
        id: item.id,
        title: item.snippet.title,
        uploader: item.snippet.channelTitle,
        thumbnail: item.snippet.thumbnails?.high?.url || "",
        duration: this.parseDurationToSeconds(item.contentDetails?.duration || "PT0S"),
        webpage_url: `https://www.youtube.com/watch?v=${item.id}`,
        formats: [], // Will be populated by audio extraction API
      }
    } catch (error) {
      console.error("[v0] YtDlp: Video info failed for:", videoId, error)
      return null
    }
  }

  async getAudioUrl(videoId: string): Promise<string | null> {
    console.log("[v0] YtDlp: Getting audio URL for:", videoId)

    try {
      // Use the audio extraction API endpoint
      const response = await fetch(`/api/youtube-music/audio/${videoId}`)
      
      if (!response.ok) {
        console.error("[v0] Audio extraction failed:", response.status)
        return null
      }

      const data = await response.json()
      return data.audioUrl || null
    } catch (error) {
      console.error("[v0] YtDlp: Audio URL failed for:", videoId, error)
      return null
    }
  }

  async getPlaylist(playlistId: string, maxResults = 50): Promise<YtDlpSong[]> {
    console.log("[v0] YtDlp: Fetching playlist from YouTube API:", playlistId)

    try {
      // Get playlist items from YouTube API
      const response = await fetch(
        `${this.YOUTUBE_BASE_URL}/playlistItems?` +
          `part=snippet&` +
          `playlistId=${playlistId}&` +
          `maxResults=${maxResults}&` +
          `key=${this.YOUTUBE_API_KEY}`,
      )

      if (!response.ok) {
        throw new Error(`YouTube API error: ${response.status}`)
      }

      const data = await response.json()
      console.log("[v0] YtDlp: Got", data.items?.length || 0, "playlist items from YouTube")

      if (!data.items || data.items.length === 0) {
        throw new Error("No playlist items from YouTube API")
      }

      // Convert playlist items to songs format
      const songs: YtDlpSong[] = data.items.map((item: any) => ({
        id: item.snippet.resourceId.videoId,
        title: item.snippet.title,
        artist: item.snippet.channelTitle,
        thumbnail: item.snippet.thumbnails?.high?.url || item.snippet.thumbnails?.medium?.url || "",
        duration: "Unknown",
        url: `https://www.youtube.com/watch?v=${item.snippet.resourceId.videoId}`,
        audioUrl: "", // Will be populated when needed
        formats: [],
      }))

      console.log("[v0] YtDlp: Successfully converted", songs.length, "playlist songs")
      return songs
    } catch (error) {
      console.error("[v0] YtDlp: Playlist failed:", error)
      throw error
    }
  }

  private convertToSong(videoInfo: YtDlpVideoInfo, youtubeItem?: any): YtDlpSong {
    return {
      id: videoInfo.id,
      title: videoInfo.title,
      artist: videoInfo.uploader || "Unknown Artist",
      thumbnail: videoInfo.thumbnail || "",
      duration: this.formatDuration(videoInfo.duration || 0),
      url: videoInfo.webpage_url,
      audioUrl: "", // Will be populated when needed
      formats: videoInfo.formats || [],
    }
  }

  private formatDuration(seconds: number): string {
    if (!seconds || seconds <= 0) return "0:00"

    const hours = Math.floor(seconds / 3600)
    const minutes = Math.floor((seconds % 3600) / 60)
    const secs = Math.floor(seconds % 60)

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")}`
    }
    return `${minutes}:${secs.toString().padStart(2, "0")}`
  }

  private parseDuration(duration: string): string {
    // Parse ISO 8601 duration (PT4M13S) to readable format (4:13)
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/)
    if (!match) return "0:00"

    const hours = parseInt(match[1] || "0")
    const minutes = parseInt(match[2] || "0")
    const seconds = parseInt(match[3] || "0")

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`
    }
    return `${minutes}:${seconds.toString().padStart(2, "0")}`
  }

  private parseDurationToSeconds(duration: string): number {
    // Parse ISO 8601 duration to seconds
    const match = duration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/)
    if (!match) return 0

    const hours = parseInt(match[1] || "0")
    const minutes = parseInt(match[2] || "0")
    const seconds = parseInt(match[3] || "0")

    return hours * 3600 + minutes * 60 + seconds
  }
}

export const createYtDlpExtractor = () => new YtDlpExtractor()
export const ytDlpExtractor = new YtDlpExtractor()
